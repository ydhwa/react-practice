# 9. 컴포넌트 스타일링

2020-04-19

## 들어가기 전에

- 일반 CSS: 컴포넌트를 스타일링하는 가장 기본적인 방식
- Sass: 자주 사용되는 CSS 전처리기(pre-processor) 중 하나로 확장된 CSS 문법을 사용하여 CSS 코드를 더욱 쉽게 작성할 수 있도록 해줌
- CSS Module: 스타일을 작성할 때 CSS 클래스가 다른 CSS 클래스의 이름과 절대 충돌하지 않도록 파일마다 고유한 이름을 자동으로 생성해 주는 옵션
- styled-components: 스타일을 자바스크립트 파일에 내장시키는 방식으로 스타일을 작성함과 동시에 해당 스타일이 적용된 컴포넌트를 만들 수 있게 해줌

```bash
yarn create react-app styling-react
cd styling-react
yarn start
```

## 가장 흔한 방식, 일반 CSS

프로젝트는 일반 CSS 방식으로 만들어져 있다. 기존의 CSS 스타일링이 불편하지 않고(ex) 소규모 프로젝트) 새로운 기술을 배울 필요가 없다고 생각되면 기존 CSS를 계속 이용해도 상관 없다.

CSS 클래스를 중복되지 않게 만드는 것이 중요하다.

### 1. 이름을 지을 때 특별한 규칙을 사용하여 짓는다.

ex) {컴포넌트명}-{클래스명}

BEM 네이밍(BEM naming) 방식도 있다. 이는 CSS 방법론 중 하나로, 이름을 지을 때 일종의 규칙을 준수하여 해당 클래스가 어디에서 어떤 용도로 사용되는지 명확하게 작성하는 방식이다.

ex) .card\_\_title-primary

### 2. CSS Selector를 활용한다.

CSS Selector를 사용하면 CSS 클래스가 특정 클래스 내부에 있는 경우에만 스타일을 적용할 수 있다.

ex) .App 안에 있는 .logo에 스타일 적용하고 싶은 경우

```css
.App .logo {
  animation: App-logo-spin infinite 20s linear;
  height: 40vmin;
}
```

컴포넌트의 최상위 html 요소에는 컴포넌트의 이름으로 클래스 이름을 짓고(.App), 그 내부에는 소문자를 입력하거나(.logo), header 같은 태그를 사용하여 클래스 이름이 불필요한 경우에는 아예 생략할 수도 있다.

## Sass 사용하기

Sass(Syntactically Awesome Style Sheets; 문법적으로 매우 멋진 스타일시트)는 CSS 전처리기로 복잡한 작업을 쉽게 할 수 있도록 해 주고, 스타일 코드의 재활용성을 높여줄 뿐만 아니라 코드의 가독성도 높여서 유지 보수를 더욱 쉽게 해 준다.

create-react-app 구버전에서는 사용하려면 추가 작업이 필요했지만, v2 버전부터는 별도의 추가 설정 없이 바로 사용할 수 있다.

Sass에서는 확장자 .scss와 .sass를 지원한다. .scss와 .sass의 문법은 상이하다.

.sass

```css
$font-stack: Helvetica, sans-serif
$primary-color: #333

body
    font: 100% $font-stack
    color: $primary-color
```

.scss

```css
$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}
```

.sass 확장자는 {}와 ;을 사용하지 않는다. .scss는 기존 CSS를 작성하는 방식과 비슷하다. 보통 .scss 문법이 더 자주 사용된다.

사용하려면 `node-sass`라는 라이브러리를 설치해 주어야 한다. 이 라이브러리는 Sass를 CSS로 변환해준다.

```bash
yarn add node-sass
```

여러 파일에서 사용할 수 있는 Sass 변수 및 믹스인은 다른 파일로 따로 분리하여 작성한 뒤 필요한 곳에서 쉽게 불러와 사용할 수 있다. 다른 scss 파일을 불러올 때는 @import 구문을 사용한다.

### sass-loader 설정 커스터마이징하기

@import 구문을 사용하여 불러오게 될 경우, 구조가 깊어지면 파일을 찾기 위해 한참 거슬러 올라가야 하는 단점이 있다.

이 문제점을 웹팩에서 Sass를 처리하는 sass-loader의 설정을 커스터마이징하여 해결할 수 있다. create-react-app으로 만든 프로젝트는 프로젝트 구조의 복잡도를 낮추기 위해 세부 설정이 모두 숨겨져 있는데, 이를 커스터마이징 하기 위해서는 프로젝트 디렉터리에서 세부 설정을 밖으로 꺼내줘야 한다.

```bash
yarn eject
```

yarn eject는 아직 Git에 커밋되지 않은 변화가 있다면 진행되지 않으므로 먼저 커밋해줘야 한다.

```bash
git add .
git commit -m "Commit before yarn eject"

yarn eject
```

성공했다면 프로젝트 디렉터리에 config라는 디렉터리가 생성된다.

(yarn eject 이후 개발 서버가 시작되지 않는 경우, 프로젝트 디렉터리의 node_modules 디렉터리를 삭제한 후, yarn install 명령어를 실행하고 yarn start를 해주면 된다.)

config/webpack.config.js를 열어서 "sassRegex" 키워드를 찾은 후 커스터마이징 한다.

### node_modules에서 라이브러리 불러오기

Sass의 장점 중 하나는 라이브러리를 쉽게 불러와서 사용할 수 있다는 점인데, yarn을 통해 설치한 라이브러리를 사용하는 가장 기본적인 방법은 상대 경로를 사용하여 node_modules까지 들어가서 불러오는 방법이다.

```css
@import "../../../node_modules/library/styles";
```

그러나 이런 구조는 스타일 파일이 깊숙한 디렉터리에 있는 경우 ../를 많이 적어야 해서 번거롭다. 이럴 땐 ~를 사용해서 불러올 수 있다.

```css
@import "~library/styles";
```

~ 사용 시 자동으로 node_modules에서 라이브러리 디렉터리를 탐지하여 스타일을 불러올 수 있다.

### 유용한 Sass 라이브러리 예제

- 반응형 디자인 쉽게 만들어주는 include-media <https://include-media.com/>
- 편리한 색상 팔레트 open-color <https://www.npmjs.com/package/open-color>

```bash
yarn add open-color include-media
```

Sass 라이브러리를 불러올 때는 node_modules 내부 라이브러리 경로 안에 들어 있는 scss 파일을 불러와야 한다. 보통 scss 파일 경로가 어디에 위치하고 있는지를 라이브러리의 공식 매뉴얼에서 알려주지 않을 때가 많으니, 직접 들어가서 확인하는 것이 좋다.

## CSS Module

CSS Module은 CSS를 불러와서 사용할 때 클래스 이름을 고유한 값, 즉 [파일 이름]\_[클래스 이름]\_[해시값] 형태로 자동으로 만들어서 컴포넌트 스타일 클래스 이름이 중첩되는 현상을 방지해 주는 기술이다.

CSS Module을 사용하기 위해 구버전(v1)의 create-react-app에서는 웹팩에서 css-loader 설정을 별도로 해주어야 했지만, v2 버전 이상부터는 따로 설정할 필요 없이 .module.css 확장자로 파일을 저장하기만 하면 CSS Module이 적용된다.

CSS Module을 사용하면 클래스 이름을 지을 때 그 고유성에 대해 고민하지 않아도 된다. 해당 클래스는 우리가 만든 스타일을 직접 불러온 컴포넌트 내부에서만 작동하기 때문이다.

특정 클래스가 웹페이지에서 전역적으로 사용되는 경우라면 :global을 앞에 입력하여 글로벌 CSS임을 명시해줄 수 있다.

CSS Module이 적용된 스타일 파일을 불러오면 객체를 하나 전달받게 되는데 CSS Module에서 사용한 클래스 이름과 해당 이름을 고유화한 값이 키-값 형태로 들어 있다.

이 고유한 이름을 사용하려면 클래스를 적용하고 싶은 JSX 엘리먼트에 `className= {styles.[클래스 이름]}` 형태로 전달해 주면 된다. :global을 사용하여 전역적으로 선언한 클래스의 경우 평상시 해왔던 것처럼 그냥 문자열로 넣어주면 된다.

CSS Module 클래스를 여러 개 사용할 때는 ES6 문법 템플릿 리터럴(Template Literal)을 사용하여 문자열을 합해주면 된다.

```javascript
const name = "리액트";
// const message = "제 이름은 " + name + "입니다.";
const message = `제 이름은 ${name}입니다.`;
```

템플릿 리터럴 문법을 사용하고 싶지 않다면 배열과 join을 이용하자.

### classnames

classnames는 CSS 클래스를 조건부로 설정할 때 매우 유용한 라이브러리이다. 또한 CSS Module을 사용할 때 이 라이브러리를 사용하면 여러 클래스를 적용할 때 매우 편리하다.

```bash
yarn add classnames
```

#### classnames 간략 사용법

```javascript
import className from "classnames";

classNames("one", "two"); // = 'one two'
classNames("one", { two: true }); // = 'one two'
classNames("one", { two: false }); // = 'one'
classNames("one", ["two", "three"]); // = 'one two three'

const myClass = "hello";
classNames("one", myClass, { myCondition: true }); // = 'one hello myCondition'
```

classnames와 CSS Module을 함께 사용하면 CSS Module 사용이 훨씬 쉬워진다. classnames에 내장되어 있는 bind 함수를 사용하면 클래스를 넣어줄 때마다 `styles.[클래스 이름]` 형태를 사용할 필요가 없다. 사전에 미리 styles에서 받아온 후 사용하게끔 설정해 두고 `cx('클래스 이름', '클래스 이름 2')` 형태로 사용할 수 있다.

### Sass와 함께 사용하기

Sass를 사용할 때도 .module.scss 확장자를 사용해 주면 CSS Module로 사용할 수 있다.

CSS Module에서 글로벌 클래스를 정의할 때 :global을 사용했던 것처럼 CSS Module이 아닌 일반 .css/.scss 파일에서도 :local을 사용하여 CSS Module을 사용할 수 있다.

```css
:local .wrapper {
  /* 스타일 */
}
:local {
  .wrapper {
    /* 스타일 */
  }
}
```

## styled-components

컴포넌트 스타일링의 또 다른 패러다임은 자바스크립트 파일 안에 스타일을 선언하는 방식이다. 이 방식을 'CSS-in-JS'라고 부르는데, 이와 관련된 라이브러리가 많다.

<https://github.com/MicheleBertoli/css-in-js>

CSS-in-JS 라이브러리 중 개발자들이 가장 선호하는 styled-components에 대해 알아보자. (styled-components를 대체할 수 있는 라이브러리로는 현재 emotion이 대표적이다. 작동 방식은 비슷하다.)

```bash
yarn add styled-components
```

styled-components 라이브러리를 사용하면 파일 하나에 스타일까지 작성할 수 있기 때문에 .css 또는 .scss 확장자를 가진 스타일 파일을 따로 만들지 않아도 된다.

styled-components와 일반 classNames를 사용하는 CSS/Sass를 비교했을 때 가장 큰 장점은 props 값으로 전달해 주는 값을 쉽게 스타일에 적용할 수 있다는 것이다.

VS code에서 styled-components 코드 신택스 하이라이팅을 정상적으로 하려면 'vscode-styled-components'를 설치하면 된다.

### Tagged 템플릿 리터럴

styled-somponents 작성 시 \`을 사용하여 만든 문자열에 스타일 정보를 넣어주는데, 여기서 사용한 문법을 Tagged 템플릿 리터럴이라고 부른다. 일반 템플릿 리터럴과의 차이점은 템플릿 안에 자바스크립트 객체나 함수를 전달할 때 온전히 추출할 수 있다는 것이다.

```javascript
`hello ${{ foo: "bar" }} ${() => "world!"}`;
// 결과: "hello [object Object] () => 'world!'"
```

템플릿에 객체를 넣거나 함수를 넣으면 형태를 잃어버리게 된다. 객체는 '[object Object]'로 변환되고, 함수는 함수 내용이 그대로 문자열화되어 나타난다.

만약 다음과 같은 함수를 작성하고 나서 해당 함수 뒤에 템플릿 리터럴을 넣어 준다면, 템플릿 안에 넣은 값을 온전히 추출할 수 있다.

```javascript
function tagged(...args) {
  console.log(args);
}
tagged`hello ${{ foo: "bar" }} ${() => "world"}!`;
```

Tagged 템플릿 리터럴을 사용하면 템플릿 사이사이에 들어가는 자바스크립트 객체나 함수의 원본 값을 그대로 추출할 수 있다. styled-components는 이러한 속성을 사용하여 styled-components로 만든 컴포넌트의 props를 스타일 쪽에서 쉽게 조회할 수 있도록 해준다.

### 스타일링된 엘리먼트 만들기

styled-components를 사용하여 스타일링된 엘리먼트를 만들 때는 컴포넌트 파일의 상단에서 styled를 불러오고, `styled.태그명`을 사용하여 구현한다.

```javascript
import styled from "styled-components";

const MyComponent = styled.div`
  font-size: 2rem;
`;
```

사용해야 할 태그명이 유동적이거나 특정 컴포넌트 자체에 스타일링 해주고 싶다면 다음과 같은 형태로 구현할 수 있다.

```javascript
// 태그의 타입을 styled 함수의 인자로 전달
const MyInput = styled("input")`
  background: gray;
`;

// 아예 컴포넌트 형식의 값을 넣어 줌
const StyledLink = styled(Link)`
  color: blue;
`;
```

### 스타일에서 props 조회하기

styled-components를 사용하면 스타일 쪽에서 컴포넌트에게 전달된 props 값을 참조할 수 있다.

이렇게 만들어진 코드는 JSX에서 사용될 때 props를 넣어줄 수 있다.

### props에 따른 조건부 스타일링

일반 CSS 클래스를 사용하여 조건부 스타일링을 해야 할 때는 className을 사용하여 조건부 스타일링을 해 왔는데, styled-components에서는 조건부 스타일링을 간단하게 props로도 처리할 수 있다.

스타일 코드 여러 줄을 props에 따라 넣어 주어야 할 때는 CSS를 styled-components에서 불어와야 한다. CSS를 사용하지 않고 바로 문자열을 넣어도 작동하기는 하지만, 해당 내용이 그저 문자열로만 취급되기 때문에 VS Code에서 신택스 하이라이팅이 제대로 되지 않고, _Tagged 템플릿 리터럴이 아니기 때문에 함수를 받아 사용하지 못해 해당 부분에서는 props 값을 사용하지 못한다._

props를 참조한다면 반드시 CSS로 감사 주어서 Tagged 템플릿 리터럴을 사용해주어야 한다.

### 반응형 디자인

브라우저의 가로 크기에 따라 다른 스타일 적용하기 위해서는 일반 CSS를 사용할 때와 똑같이 media 쿼리(query)를 사용하면 된다.

일반 CSS와 큰 차이가 없으나, 이러한 작업을 여러 컴포넌트에서 반복해야 한다면 번거로울 수 있다. 그럴 때는 이 작업을 함수화하여 간편하게 사용할 수 있다. styled-components 매뉴얼에서 제공하는 유틸 함수를 사용해보자.

```javascript
import React from "react";
import styled, { css } from "styled-components";

const sizes = {
  desktop: 1024,
  tablet: 768,
};

// 위에 있는 size 객체에 따라 자동으로 media 쿼리 함수를 만들어 준다.
// 참고: https://styled-components.com/docs/advanced#media-templates
const media = Object.keys(sizes).reduce((acc, label) => {
  acc[label] = (...args) => css`
    @media (max-width: ${sizes[label] / 16}em) {
      ${css(...args)};
    }
  `;
  return acc;
}, {});

const Box = styled.div`
  /* props로 넣어준 값을 직접 전달해 줄 수 있다. */
  background: ${(props) => props.color || "blue"};
  padding: 1rem;
  display: flex;
  width: 1024px;
  margin: 0 auto;
  ${media.desktop`width: 768px`};
  ${media.tablet`width: 100%`};
`;
```

실제 사용 시 media를 아예 다른 파일로 모듈화한 뒤 여기저기서 불러와 사용하는 방식이 훨씬 편할 것이다.

#### Note

Link 컴포넌트는 나중에 리액트 라우터를 배울 때 사용할 컴포넌트이다. 이런 식으로 컴포넌트를 styled의 파라미터에 넣는 경우에는 해당 컴포넌트에 className props를 최상위 DOM의 className 값으로 설정하는 작업이 내부적으로 되어 있어야 한다.
