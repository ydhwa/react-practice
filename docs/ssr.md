# 서버 사이드 렌더링

2020-05-27

## 서버 사이드 렌더링의 이해

서버 사이드 렌더링은 UI를 서버에서 렌더링하는 것을 의미한다. 클라이언트 사이드 렌더링은 UI 렌더링을 모두 브라우저에서 처리하는 것으로, 자바스크립트를 실행해야 우리가 만든 화면이 사용자에게 보여진다.

```
yarn create react-app ssr-recipe
cd ssr-recipe
yarn start
```

서버 사이드 렌더링을 구현하면 사용자가 웹 서비스에 방문했을 때 서버 쪽에서 초기 렌더링을 대신해 준다. 그리고 사용자가 HTML을 전달받을 떄 그 내부에 렌더링된 결과물이 보인다.

### 장점

1.  검색 엔진의 최적화

검색 엔진이 우리가 만든 웹 애플리케이션의 페이지를 원활하게 수집할 수 있다. 리액트로 만든 SPA는 검색 엔진 크롤러 봇처럼 자바스크립트가 실행되지 않는 환경에서는 페이지가 제대로 나타나지 않는다. 따라서 서버에서 클라이언트 대신 렌더링을 해 주면 검색 엔진이 페이지의 내용을 제대로 수집해 갈 수 있다.

2. 초기 렌더링 성능 개선

서버 사이드 렌더링이 구현되지 않은 웹 페이지에 사용자가 방문하면, 자바스크립트가 로딩되고 실행될 때까지 사용자는 비어 있는 페이지를 보며 대기해야 한다. 여기에 API까지 호출해야 한다면 사용자의 대기 시간이 더더욱 길어진다. 반면 서버 사이드 렌더링을 구현한 웹 페이지라면 자바스크립트 파일 다운로드가 완료되지 않은 시점에서도 HTML 상에 사용자가 볼 수 있는 컨텐츠가 있기 때문에 대기 시간이 최소화되고, 이로 인해 사용자 경험이 향상된다.

### 단점

1. 서버 리소스가 사용됨

서버 사이드 렌더링은 결국 원래 브라우저가 해야 할 일을 서버가 대신 처리하는 것이므로 서버 리소스가 사용된다. 갑자기 많은 사용자가 동시에 웹 페이지에 접속하면 서버에 과부하가 발생할 수 있다. 따라서 사용자가 많은 서비스라면 캐싱과 로드 밸런싱을 통해 성능을 최적화해 주어야 한다.

2. 개발의 어려움

프로젝트의 구조가 좀 더 복잡해질 수 있고, 데이터 미리 불러오기, 코드 스필리팅과의 호환 등 고려해야 할 사항이 많아져서 개발이 어려워질 수 있다.

### 서버 사이드 렌더링과 코드 스플리팅의 충돌

서버 사이드 렌더링과 코드 스플리팅을 함께 적용하면 작업이 까다로워진다. 별도의 호환 작업 없이 두 기술을 함께 적용하면, 다음과 같은 흐름으로 작동하면서 페이지에 깜박임이 발생한다.

1. 서버 사이드 렌더링된 결과물이 브라우저에 나타남
2. 자바스크립트 파일 로딩 시작
3. 자바스크립트가 실행되면서 아직 불러오지 않은 컴포넌트를 null로 렌더링함
4. 페이지에서 코드 스플리팅된 컴포넌트들이 사라짐
5. 코드 스플리팅된 컴포넌트들이 로딩된 이후 제대로 나타남

이러한 이슈를 해결하기 위해서는 라우트 경로마다 코드 스플리팅된 파일 중에서 필요한 모든 파일을 브라우저에서 렌더링하기 전에 미리 불러와야 한다.

여기서는 이 문제점을 다음과 같은 방법으로 해결한다:

> Loadable Components 라이브러리에서 제공하는 기능을 써서 서버 사이드 렌더링 후 필요한 파일의 경로를 추출하여 렌더링 결과에 스크립트/스타일 태그를 삽입해 준다.

## 프로젝트 준비하기

```
yarn add react-router-dom
```

## 서버 사이드 렌더링 구현하기

서버 사이드 렌더링을 구현하려면 웹팩 설정을 커스터마이징 해 주어야 한다. CRA로 만든 프로젝트에서는 웹팩 관련 설정이 기본적으로 모두 숨겨져 있으니 `yarn eject` 명령어를 실행하여 밖으로 꺼내 준다.

```
git add .
git commit -m "Commit before eject"
yarn eject
```

### 서버 사이드 렌더링용 엔트리 만들기

**엔트리(entry)** 는 웹팩에서 프로젝트를 불러올 때 가장 먼저 불러오는 파일이다. 예를 들어 현재 작성 중인 리액트 프로젝트에서는 index.js를 엔트리 파일로 사용한다. 이 파일부터 시작하여 내부에 필요한 다른 컴포넌트와 모듈을 불러오고 있는 것이다.

서버 사이드 렌더링을 할 때는 서버를 위한 엔트리 파일을 따로 생성해야 한다. (여기서는 `/src/index.server.js`)

서버에서 리액트 컴포넌트를 렌더링할 때는 ReactDOMServer의 renderToString이라는 함수를 사용한다. 이 함수에 JSX를 넣어서 호출하면 렌더링 결과를 문자열로 반환한다.

### 서버 사이드 렌더링 전용 웹팩 환경 설정 작성하기

작성한 엔트리 파일을 웹팩으로 불러와서 빌드하려면 서버 전용 환경 설정을 만들어 주어야 한다. (`config/paths.js`)

다음에는 웹팩 환경 설정 파일을 작성한다. (`config/webpack.config.server.js`) 빌드할 때 어떤 파일에서 시작해 파일들을 불러오는지, 또 어디에 결과물을 저장할지를 정해준다.

다음에는 로더를 설정해준다. 웹팩의 로더는 파일을 불러올 때 확장자에 맞게 필요한 처리를 해 준다. 예를 들어 자바스크립트는 babel을 사용하여 트랜스파일링을 해 주고, CSS는 모든 CSS 코드를 결합해 주고, 이미지 파일은 파일을 다른 경로에 따로 저장하고 그 파일에 대한 경로를 자바스크립트에서 참조할 수 있게 해준다.

서버 사이드 렌더링 시 CSS 혹은 이미지 파일은 그다지 중요하지 않지만 완전히 무시할 수는 없다. 가끔 자바스크립트 내부에서 파일에 대한 경로가 필요하거나 CSS Module처럼 로컬 className을 참조해야 할 수도 있기 때문이다. 그래서 해당 파일을 로더에서 별도로 설정하여 처리하지만 따로 결과물에 포함되지 않도록 구현할 수 있다. (`config/webpack.config.server.js`)

브라우저에서 사용할 때는 결과물 파일에 라이브러리와 우리의 애플리케이션에 관한 코드가 공존해야 하는데, 서버에서는 굳이 결과물 파일 안에 리액트 라이브러리가 들어 있지 않아도 된다. node_modules를 통해 바로 불러와서 사용할 수 있기 때문이다.

따라서 서버를 위해 번들링할 때는 node_modules에서 불러오는 것을 제외하고 번들링하는 것이 좋다. 이를 위해 webpack-node-externals라는 라이브러리를 사용해야 한다.

```
yarn add webpack-node-externals
```

이 라이브러리를 webpack-config.server.js 상단에 불러와서 설정에 적용한다.

환경 설정 파일을 다 작성했다면 환경변수를 주입해준다. 환경변수를 주입하면 프로젝트 내에서 process.env.NODE_ENV 값을 참조하여 현재 개발 환경인지 아닌지를 알 수 있다.

### 빌드 스크립트 작성하기

## 데이터 로딩

## 서버 사이드 렌더링과 코드 스플리팅

## 서버 사이드 렌더링의 환경 구축을 위한 대안

## 정리
