# 리액트 라우터로 SPA 개발하기

2020-04-25

## SPA란?

SPA란 Single Page Application의 약자로, '한 개의 페이지로 이루어진 애플리케이션'이라는 의미이다.

전통적인 웹 페이지는 여러 페이지로 구성되어 있어 사용자가 다른 페이지로 이동할 때마다 새로운 html을 받아 오고, 페이지를 로딩할 때마다 서버에서 리소스를 전달받아 해석한 뒤 화면에 보여주었다. 이렇게 사용자에게 보이는 화면을 서버 측에서 준비했다.

요즘은 웹에서 제공되는 정보가 많으므로 새로운 화면을 보여 주어야 할 때마다 서버 측에서 모든 뷰를 준비하면 성능상의 문제가 발생할 수 있다. 트래픽이 많이 나올 수도 있고, 사용자가 몰려 서버에 높은 부하가 쉽게 걸릴 수도 있다. 속도와 트래픽 측면에서는 캐싱과 압축을 해서 서비스를 제공하면 어느 정도 최적화될 수 있겠지만, 사용자와의 상호작용이 자주 발생하는 모던 웹 애플리케이션에는 적당하지 않을 수 있다.

그래서 리액트 같은 라이브러리 혹은 프레임워크를 사용하여 뷰 렌더링을 사용자의 브라우저가 담당하도록 하고, 우선 애플리케이션을 브라우저에 불러와서 실행시킨 후에 사용자와의 상호작용이 발생하면 필요한 부분만 자바스크립트를 사용하여 업데이트 해준다. 만약 새로운 데이터가 필요하다면 서버 API를 호출하여 필요한 데이터만 새로 불러와 애플리케이션에서 사용한다.

싱글페이지라고 화면이 한 종류인 것은 아니다. SPA의 경우 서버에서 사용자에게 제공하는 페이지는 한 종류이지만, 해당 페이지에서 로딩된 자바스크립트와 현재 사용자 브라우저의 주소 상태에 따라 다양한 화면을 보여줄 수 있다.

다른 주소에 다른 화면을 보여주는 것을 라우팅이라고 한다. 리액트 라이브러리 자체에 이 기능이 내장되어 있지는 않지만, 브라우저의 API를 직접 사용하여 이를 관리하거나 라이브러리를 사용하여 이 작업을 쉽게 구현할 수 있다.

리액트 라우팅 라이브러리는 리액트 라우터(react-router), 리치 라우트(reach-router), Next.js 등 여러 가지가 있다.

리액트 라우터는 클라이언트 사이드에서 이루어지는 라우팅을 간단하게 구현할 수 있도록 해 준다. 더 나아가서 나중에 서버 사이드 렌더링을 할 때도 라우팅을 도와주는 컴포넌트들을 제공해준다.

### SPA 단점

앱의 규모가 커지면 자바스크립트 파일이 너무 커진다. 페이지 로딩 시 사용자가 실제로 방문하지 않을 수도 있는 페이지의 스크립트도 불러오기 때문이다. 하지만 이는 코드 스플리팅(code splitting)을 사용하면 라우트 별로 파일들을 나누어서 트래픽과 로딩 속도를 개선할 수 있다.

리액트 라우터처럼 브라우저에서 자바스크립트를 사용하여 라우팅을 관리하는 것은 자바스크립트를 실행하지 않는 일반 크롤러에서는 페이지의 정보를 제대로 수집해 가지 못한다는 잠재적인 단점이 따른다. 또한, 자바스크립트 실행될 때까지 페이지가 비어 있기 때문에 자바스크립트 파일이 로딩되어 실행되는 짧은 시간 동안 흰 페이지가 나타날 수 있다는 단점도 있다.

위와 같은 문제점들은 서버 사이드 렌더링(server-side rendering)을 통해 모두 해결할 수 있다.

## 프로젝트 준비 및 기본적인 사용법

```bash
yarn create react-app router-tutorial
cd router-tutorial

# 리액트 라우터 라이브러리 설치
yarn add react-router-dom
```

### 프로젝트에 라우터 적용

프로젝트에 리액트 라우터 적용 시 src/index.js 파일에서 react-router-dom에 내장되어 있는 BrowserRouter 컴포넌트를 사용하여 감싸면 된다. 이 컴포넌트는 웹 애플리케이션에 HTML5의 History API를 사용하여 페이지를 새로고침하지 않고도 주소를 변경하고, 현재 주소와 관련된 정보를 props로 쉽게 조회하거나 사용할 수 있도록 해준다.

<코드 참고 - index.js>

### 페이지 만들기

<코드 참고 - Home.js, About.js>

### Route 컴포넌트로 특정 주소에 컴포넌트 연결

Route 컴포넌트를 사용하여 사용자의 현재 경로에 따라 다른 컴포넌트를 보여준다. Route 컴포넌트를 사용하면 어떤 규칙을 가진 경로에 어떤 컴포넌트를 보여 줄지 정의할 수 있다.

```javascript
<Route path="주소 규칙" component={보여 줄 컴포넌트} />
```

<코드 참고 - App.js>

Route에 exact={true}로 설정해주면 규칙이 아니라 정확히 경로가 일치했을 때 해당 컴포넌트를 보여준다.

### Link 컴포넌트를 사용하여 다른 주소로 이동하기

Link 컴포넌트는 클릭하면 다른 주소로 이동시켜 주는 컴포넌트이다. 다른 웹 애플리케이션에서는 a 태그를 사용하여 페이지를 전환하나, **_리액트 라우터를 사용할 때는 이 태그를 직접 사용하면 안 된다._**

a 태그는 페이지를 전환하는 과정에서 페이지를 새로 불러오기 때문에 애플리케이션이 들고 있던 상태들을 모두 날려버린다. 렌더링된 컴포넌트도 모두 사라지고 처음부터 렌더링하게 된다.

**Link 컴포넌트를 사용하여 페이지를 전환** 하면, 페이지를 새로 불러오지 않고 애플리케이션은 그대로 유지한 상태에서 HTML5 History API를 사용하여 페이지의 주소만 변경해 준다. Link 컴포넌트 자체는 a 태그로 이루어져 있으나, 페이지 전환을 방지하는 기능이 내장되어 있다.

```javascript
<Link to="주소">내용</Link>
```

<코드 참고 - App.js>

## Route 하나에 여러 개의 path 설정하기

Route 하나에 여러 개의 path를 지정하는 것은 최신 버전의 리액트 라우터 v5부터 적용된 기능이다. 이전 버전에서는 여러 개의 path에 컴포넌트를 보여주려면 Route 컴포넌트를 여러 번 작성해야 했다.

하지만 최신 버전의 리액트 라우터에서는 path props를 배열로 설정해주면 여러 경로에서 같은 컴포넌트를 보여줄 수 있다.

<코드 참고 - App.js>

## URL 파라미터와 쿼리

페이지 주소를 정의할 때 유동적인 값을 전달해야 할 때가 있다.

- 파라미터: /members/{memberId}
- 쿼리: /members?username=ydhwa

### URL 파라미터

<코드 참고 - Profile.js>

URL 파라미터 사용 시 라우트로 사용되는 컴포넌트에서 받아 오는 match라는 객체 안의 params 값을 참조한다. match 객체 안에는 현재 컴포넌트가 어떤 경로 규칙에 의해 보이는지에 대한 정보가 들어있다.

<코드 참고 - App.js>

### URL 쿼리

쿼리는 location 객체에 들어 있는 search 값에서 조회할 수 있다. location 객체는 라우트로 사용된 컴포넌트에게 props로 전달되며, 웹 애플리케이션의 현재 주소에 대한 정보를 지니고 있다.

location의 형태는 다음과 같다.

```json
{
  "pathname": "/about",
  "search": "?detail=true",
  "hash": ""
}
```

URL 쿼리를 읽을 때는 위 객체가 지닌 값 중에서 search 값을 확인해야 한다. 이 값은 문자열 형태로 되어 있다. URL 쿼리는 `?detail=true&another=1`과 같이 문자열에 여러 가지 값을 설정해줄 수 있다. search 값에서 특정 값을 읽어오기 위해서는 이 문자열을 객체 형태로 변환해줘야 한다.

쿼리 문자열을 객체로 변환할 때는 qs 라이브러리를 사용한다.

```bash
yarn add qs
```

<코드 참고 - About.js>

쿼리를 사용할 때는 쿼리 문자열을 객체로 파싱하는 과정에서 결과 값은 언제나 문자열이라는 점에 주의해야 한다. `?value=1`이나 `?value=true`와 같이 숫자나 논리 자료형을 사용한다고 해서 우리가 원하는 형태로 변하는 것이 아니라 "1", "true"와 같이 문자열 형태로 받아진다.

그러므로 숫자를 받아와야 한다면 parseInt 함수를 통해 숫자로 변환해줘야 하고, 논리 자료형 값을 사용해야 하는 경우에는 정확히 "true" 문자열이랑 일치하는지 비교해줘야 한다.

## 서브 라우트

## 리액트 라우터 부가 기능

## 정리
