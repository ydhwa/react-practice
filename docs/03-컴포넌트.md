# 3. 컴포넌트

2020-04-02 ~ 2020-04-03

## 클래스형 컴포넌트

### 컴포넌트를 선언하는 방식

1. 함수형 컴포넌트(2장에서 사용)
2. 클래스형 컴포넌트

   ```javascript
   import React, { Component } from "react";

   class App extends Component {
     render() {
       const name = "react";
       return <div className="react">{name}</div>;
     }
   }

   export default App;
   ```

   클래스형 컴포넌트는 `state` 기능 및 라이프사이클 기능을 사용할 수 있으며, 임의 메서드를 정의할 수 있다.

   클래스형 컴포넌트에서는 `render` 함수가 꼭 있어야 하고, 그 안에서 보여주어야 할 JSX를 반환해야 한다.

### 어떤 상황에서 어떤 방식으로 컴포넌트를 선언해야 할까?

1. 함수형 컴포넌트
   1. 장점
      1. 클래스형 컴포넌트보다 선언하기 편하다.
      2. 클래스형 컴포넌트에 비해 메모리 자원을 덜 사용한다.
      3. 프로젝트 완성 후 빌드하여 배포할 때에도 클래스형 컴포넌트에 비해 파일 크기가 더 작다.(성능과 파일 크기 면에서 별로 차이가 나지 않긴 함)
   2. 단점
      1. `state`와 라이프사이클 API 사용이 불가능하다.
         1. 리액트 v16.8 업데이트 이후 Hooks가 도입되면서 해결됨

공식 문서에서는 컴포넌트 새로 작성 시 함수형 컴포넌트와 Hooks를 사용하도록 권장한다.

함수형 컴포넌트 선언 시 `function` 키워드를 사용하는 것과 화살표 함수 문법을 사용하는 것 사이에는 큰 차이가 없으나, 화살표 함수 문법이 조금 더 간결하다.

## props
- properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는 요소
- props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수 있음

### PropTypes 종류
| 종류                                                       | 설명                                                            |
| -------------------------------------------------------- | ------------------------------------------------------------- |
| array                                                    | 배열                                                            |
| arrayOf(다른 PropType)                                     | 특정 PropType으로 이루어진 배열(ex) PropTypes.number)                   |
| bool                                                     | true 혹은 false 값                                               |
| func                                                     | 함수                                                            |
| number                                                   | 숫자                                                            |
| object                                                   | 객체                                                            |
| string                                                   | 문자열                                                           |
| symbol                                                   | ES6의 symbol                                                   |
| node                                                     | 렌더링할 수 있는 모든 것(숫자, 문자열 혹은 JSX 코드. children도 node PropType이다.) |
| instanceOf(클래스)                                          | 특정 클래스의 인스턴스(ex) instanceOf(MyClass))                         |
| oneOf(['dog', 'cat'])                                    | 주어진 배열 요소 중 값 하나                                              |
| oneOfType([React.PropTypes.number])                      | 객체의 모든 키 값이 인자로 주어진 PropType인 객체                              |
| shape({ name: PropTypes.string, num: PropTypes.number }) | 주어진 스키마를 가진 객체                                                |
| any                                                      | 아무 종류                                                         |

### 클래스형 컴포넌트에서 props 사용하기
클래스형 컴포넌트에서 props를 사용하려면 render 함수에서 this.props를 조회하면 된다. defaultProps와 propTypes는 똑같은 방식으로 설정할 수 있다.

## state
- 컴포넌트 내부에서 바뀔 수 있는 값

### props와의 비교
- props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props를 읽기 전용으로만 사용할 수 있다.
- props를 변경하려면 부모 컴포넌트에서 바꿔줘야 한다.

### 클래스형 컴포넌트의 state
- this.setState 사용
- this.setState(prevState, props)
  - prevState: 기존 상태
  - props: 현재 지니고 있는 props(업데이트 과정에서 props 필요 없다면 생략 가능)
- this.setState 끝난 후 특정 작업 실행하려면 setState의 두 번째 파라미터로 callback 함수를 등록하여 작업 처리 가능

### 함수형 컴포넌트에서 useState 사용하기
- react 16.8 이전 버전에서는 함수형 컴포넌트에서 state 사용 불가
- useState 함수를 사용하여 함수형 컴포넌트에서도 state 사용 가능

#### Hooks
- 배열 비구조화 할당: 객체 비구조화 할당과 비슷한데, 배열 안에 들어 있는 값을 쉽게 추출할 수 있도록 해 주는 문법이다.
  ```javascript
  const array = [1, 2]
  const [one, two] = array;
  ```

#### useState
- useState 함수의 인자에는 상태의 초기값을 넣어준다.
- 클래스형 컴포넌트에서의 state 초기값은 객체 형태를 넣어줘야 하나, useState에서는 반드시 객체가 아니어도 괜찮다.
- 한 컴포넌트에서 여러 번 사용해도 괜찮다.
- 함수를 호출하면 배열이 반환됨
  - 첫 번째 원소: 현재 상태
  - 두 번째 원소: 상태를 바꿔주는 함수(setter 함수)
  - 배열 비구조화 할당을 통해 이름 자유롭게 정해줄 수 있다.

## Note

### ES6의 클래스 문법

_ES6 이전: `class`가 존재하지 않아 `prototype`을 사용함_

```javascript
function Dog(name) {
  this.name = name;
}

Dog.prototype.say = function() {
  console.log(this.name + ": 멍멍");
};
var dog = new Dog("검둥이");
dog.say(); // 검둥이: 멍멍
```

_ES6_

```javascript
class Dog {
  constructor(name) {
    this.name = name;
  }
  say() {
    console.log(this.name + ": 멍멍");
  }
}

const dog = new Dog("흰둥이");
dog.say(); // 흰둥이: 멍멍
```

### ES6의 화살표 함수(arrow function)

ES6 문법에서 함수를 표현하는 새로운 방식이다. 기존 `function`을 이용한 함수 선언 방식과는 사용 용도가 약간 다른데(=기존 `function` 대체 불가능), 이 문법은 주로 **함수를 파라미터로 전달할 때** 유용하다.

```javascript
function BlackDog() {
  this.name = "흰둥이";
  return {
    name: "검둥이",
    bark: function() {
      console.log(this.name + ": 멍멍!");
    }
  };
}

const blackDog = new BlackDog();
blackDog.bark(); // 검둥이: 멍멍!

function WhiteDog() {
  this.name = "흰둥이";
  return {
    name: "검둥이",
    bark: () => {
      console.log(this.name + ": 멍멍!");
    }
  };
}

const whiteDog = new WhiteDog();
whiteDog.bark(); // 흰둥이: 멍멍!
```

일반 함수는 자신이 종속된 객체를 `this`로 가리키며, 화살표 함수는 자신이 종속된 인스턴스를 가리킨다.

화살표 함수는 값을 연산하여 바로 반환해야 할 때 사용하면 가독성을 높일 수 있다.

```javascript
function twice(value) {
  return value * 2;
}

const triple = value => value * 3;
```
