# 리덕스 미들웨어를 통한 비동기 작업

2020-05-24

## 들어가기 전에

리액트 웹 애플리케이션에서 API 서버 연동 시 API 요청에 대한 상태도 잘 관리해야 한다. 예를 들어 요청이 시작되었을 때는 로딩 중임을, 요청이 성공/실패했을 때는 로딩이 끝났음을 명시해야 한다. 요청이 성공하면 서버에서 받아 온 응답에 대한 상태를 관리해야 하고, 요청이 실패하면 서버에서 반환한 에러에 대한 상태를 관리해야 한다.

리액트 프로젝트에서 리덕스를 사용하고 있고 이러한 비동기 작업을 관리해야 한다면 middleware를 사용하여 매우 효율적이고 편하게 상태 관리를 할 수 있다.

## 작업 환경 준비

```
yarn create react-app learn-redux-middleware
yarn add redux react-redux redux-actions
```

## 미들웨어란?

리덕스 미들웨어는 액션을 디스패치했을 때 리듀서에서 이를 처리하기에 앞서 사전에 지정된 작업들을 실행한다. 액션과 리듀서 사이의 중간자라고 볼 수 있다.

`액션 -> 미들웨어 -> 리듀서 -> 스토어`

리듀서가 액션을 처리하기 전에 미들웨어가 할 수 있는 작업은 여러 가지가 있다. 전달받은 액션을 단순히 콘솔에 기록하거나, 전달받은 액션 정보를 기반으로 액션을 아예 취소하거나, 다른 종류의 액션을 추가로 디스패치할 수 있다.

(액션이 디스패치될 때마다 액션의 정보와 액션이 디스패치되기 전후의 상태를 콘솔에 보여주는 로깅 미들웨어 작성)

미들웨어는 결국 함수를 반환하는 함수이다. 파라미터로 받아 오는 store는 리덕스 스토어 인스턴스를, action은 디스패치된 액션을 가리킨다. next 파라미터는 함수 형태이며, store.dispatch와 비슷한 역할을 한다. 그러나 큰 차이점이 있는데, next(action)을 호출하면 그 다음 처리해야 할 미들웨어에게 액션을 넘겨주고, 만약 그 다음 미들웨어가 없다면 리듀서에게 액션을 넘겨준다는 것이다.

미들웨어 내부에서 store.dispatch를 사용하면 첫 번째 미들웨어부터 다시 처리한다. 만약 미들웨어에서 next를 사용하지 않으면 액션이 리듀서에 전달되지 않는다. (즉, 액션이 무시된다.)

미들웨어에서는 특정 조건에 따라 액션을 무시하게 할 수도 있고, 특정 조건에 따라 액션 정보를 가로채서 변경한 후 리듀서에게 전달해 줄 수도 있다. 아니면 특정 액션에 기반하여 새로운 액션을 여러 번 디스패치할 수도 있다.

이러한 미들웨어 속성을 사용하여 네트워크 요청과 같은 비동기 작업을 관리하면 매우 유용하다.

### redux-logger 사용하기

오픈 소스 커뮤니티에 올라와 있는 redux-logger 미들웨어 설치 및 사용해보기

```
yarn add redux-logger
```

## 비동기 작업을 처리하는 미들웨어 사용

- redux-thunk: 비동기 작업을 처리할 때 가장 많이 사용하는 미들웨어. 객체가 아닌 함수 형태의 액션을 디스패치할 수 있게 해줌
- redux-saga: redux-thunk 다음으로 가장 많이 사용되는 비동기 작업 관련 미들웨어 라이브러리. 특정 액션이 디스패치되었을 때 정해진 로직에 따라 다른 액션을 디스패치시키는 규칙을 작성하여 비동기 작업을 처리할 수 있게 해줌

### redux-thunk

Thunk란 특정 작업을 나중에 할 수 있도록 미루기 위해 함수 형태로 감싼 것이다.

```
yarn add redux-thunk
```

### 웹 요청 비동기 작업 처리하기

thunk의 속성을 활용하여 웹 요청 비동기 작업을 처리하는 방법 알아보기.

예시 데이터: <https://jsonplaceholder.typicode.com/>

```
GET https://jsonplaceholder.typicode.com/posts/:id
GET https://jsonplaceholder.typicode.com/users
```

API 호출 시 주로 Promise 기반 웹 클라이언트인 axios를 사용한다.

```
yarn add axios
```

### redux-saga

- redux-thunk: 함수 형태의 액션을 디스패치하여 미들웨어에서 해당 함수에 스토어의 dispatch와 getState를 파라미터로 넣어서 사용하는 원리
- 다음과 같은 경우에는 redux-saga를 사용하는 것이 유리
  - 기본 요청을 취소 처리해야 할 때(불필요한 중복 요청 방지)
  - 특정 액션이 발생했을 때 다른 액션을 발생시키거나, API 요청 등 리덕스와 관계없는 코드를 실행할 때
  - 웹소켓을 사용할 때
  - API 요청 실패 시 재요청해야 할 때

#### 제너레이터 함수 이해하기

redux-saga에서는 ES6의 제너레이터(generator) 함수라는 문법을 사용한다. 보통 일반적인 상황에서는 많이 사용하지 않는다.

제너레이터 함수 문법의 핵심 기능은 함수를 작성할 때 함수를 특정 구간에 멈춰 놓을 수도 있고, 원할 때 다시 돌아가게 할 수도 있다.

```javascript
function* generatorFunction() {
  console.log(1);
  yield 1;
  console.log(2);
  yield 2;
  console.log(3);
  yield 3;
  return 4;
}
```

제너레이터 함수를 만들 때는 `function*` 키워드를 사용한다.

함수를 작성한 뒤에는 `const generator = generatorFunction()` 코드를 사용하여 제너레이터를 생성한다.

제너레이터 함수를 호출했을 때 반환되는 객체를 제너레이터라고 부른다.

제너레이터가 처음 만들어지면 함수의 흐름은 멈춰있는 상태다. `next()`가 호출되면 다음 `yield`가 있는 곳까지 진행되고 함수가 멈춘다. 제너레이터 함수를 사용하면 함수를 도중에 멈출 수도 있고, 순차적으로 여러 값을 반환시킬 수도 있다.

redux-saga는 제너레이터 함수 문법을 기반으로 비동기 작업을 관리해 준다. 즉, redux-saga는 우리가 디스패치하는 액션을 모니터링해서 그에 따라 필요한 작업을 따로 수행할 수 있는 미들웨어이다.

```
yarn add redux-saga
```

```
yarn add redux-devtools-extension
```

- takeEvery: 디스패치되는 모든 액션에 대해 액션을 발생시켜 준다.
- takeLatest: 여러 액션이 중첩되어 디스패치되었을 때는 기존의 것들을 무시하고 가장 마지막 액션만 제대롤 처리한다.

#### 유용한 기능

- 사가 내부에서 현재 상태 조회: select

  ```javascript
  function* increaseSaga() {
    yield delay(1000);
    yield put(increase()); // 특정 액션 디스패치함

    const number = yield select((state) => state.counter); // state는 스토어 상태를 의미함
    console.log(`현재 값은 ${number} 입니다.`);
  }
  ```

- 사가가 실행되는 주기 제한: throttle (사가가 n초에 단 한 번만 호출되도록 설정 가능)

- 그 외 기능들은 공식 문서(<https://redux-saga.js.org/>) 참고

## 정리

리덕스 미들웨어를 사용하는 방법과 비동기 작업을 미들웨어로 처리하는 방법에 대해서 알아보았다.

- redux-thunk: 일반 함수로 이루어져 있기 때문에 간단명료함
- redux-saga: 진입 장벽이 있으나 복잡한 상황에서 효율적으로 작업을 관리할 수 있음

이 외에도 비동기 작업을 할 때는 redux-promise-middleware, redux-pender, redux-observable 등 미들웨어를 시도해 봐도 좋다.

아니면 미들웨어를 사용하지 않고 그냥 컴포넌트 단에서 API를 요청하는 방법도 틀린 방법은 아니다. 리덕스 미들웨어를 사용하는 이유는 결국 좀 더 편하게 처리하기 위해서이기 때문이다.
